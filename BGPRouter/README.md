# BGP Router
This project is a simple BGP router implementation written in Python, in an event-driven style. BGP is an exterior gateway protocol (EGP) that is used to exchange routing information between autonomous systems (AS) on the Internet. The router maintains a table of routing information called the BGP routing table, or in simple words, a forwarding table, which includes information about the best paths to reach destination networks. It accepts route update or withdraw messages from the BGP neighbors, and forwards the updates as appropriate. It forwards data packets towards their correct destination upon a request, if it has a path to the destination. It also supports the aggregation of forwarding table entries for networks that are adjacent and on the same port for increase efficiency.

## High-Level Approach
I took this project one step at a time. The first step was to understand the started code, and to get familiar with event-driven programming style in python using the select library's select function (select.select). I then implemented basic support for “update” and “data” messages. I assumed all of the neighboring routers are customers and that there will be no overlapping routes. Upon receiving an update, I would add the announced route to the table as is, and forward the announcement to all neighbors except the source of the announcement. Thus, forwarding data to the destination simply required a quick lookup in my forwarding table to determine the route to the desired destination. Then, I implemented support for the "dump" messages, and the “table” response message. Then, I implemented the algorithm for choosing the best path based on the different attributes that come with each route announcement. The next step was to support withdraw messages, which would require the removal of the route from the forwarding table. In case where the router has no path to the destination of a “data” message, then I would respond with a "no route" message back to the source neighbor. Next, I had to add support for enforcing peering and provider/customer relationships, i.e, restricting which neighbors receive “update” and “withdraw” messages, as well as dropping “data” messages when the transit relationship is not profitable. Next, I added support for the longest prefix match. To do this, I decided to sort my forwarding table by ascending order of the netmask in CIDR notation, and to find the different routes to a particular destination with the maximum prefix match. Finally, a tricky part of the project was adding support for aggregation, and re-aggregation upon receiving a withdraw announcement for a route. To do this, I decided to have one unaggregated forwarding table, that gets updates after every announcement (update -> add route, revocation -> remove route). Thus, after every revocation, the unaggregated table is updated, and the aggregated forwarding table is rebuilt using that updated table.  

## Challenges Faced
I did not face a lot of challenges with this project given that I broke it down into smaller components that can be tackled carefully and thoughtfully. Perhaps one challenge was the aggregation/disaggregation. I initially did not think of maintaining two tables, one aggregated and one unaggregated, so I had to think of efficient ways of disaggregating a single aggregated network upon receiving a revocation. This was very tricky, and hard to implement. Luckily, I found an easier and more efficient solution before having to implement the inefficient and hard way of doing it. 

## Good Properties/Features of the Design
Firstly, and most importantly, maintaining an unaggregated and aggregated table was a good design choice, that helped me simplify the code required to rebuild the table upon receiving a revocation. Second, I split the different functionalities into small functions to aid the debugging process. Finally, I made use of binary bitwise operations to efficiently determine longest prefix match, and other operations. 

## Testing
For this project, we were given different configuration files that set up the manual configuration process of a BGP router, and run various simulations. I made use of these configurations and tests to verify the functionality of my program. I also used print statements to inspect the state of my program. 
